(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{425:function(r,n,a){"use strict";a.r(n);var e=a(2),o=Object(e.a)({},(function(){var r=this,n=r._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[n("p",[r._v("数组\n//创建数组方式（2）")]),r._v(" "),n("ol",[n("li",[n("p",[r._v("var arr = new Array(); //利用new关键字\n注意：括号里只写一个数，表长度；多个数表内容")])]),r._v(" "),n("li",[n("p",[r._v("var arr = ['小黑','小白','小黄','小兰'] //*利用数组字面量（推荐）\n//遍历数组，将数组里的元素从头到尾访问一次\nvar arr = ['星期一','星期二','星期三','星期四','星期五','星期六','星期日']\nfor (i = 0; i < arr.length;i++){\nconsole.log(arr[i])\n}\n//求一个数组中的最大值\nvar arr = [2,6,1,7,4,77,52,25]\nvar max = arr[0]\nfor (i = 0; i < arr.length;i++){\nmax = max > arr[i]? max : arr[i]\n}\nconsole.log('最大值为:' + max)\n//将数组转为字符串\nvar arr = [2,6,1,7,4,77,52,25]\nvar str = ''\nvar sep = '|'\nfor (i = 0; i < arr.length;i++){\nstr = str + arr[i] + sep\n}\nconsole.log(str)")])])]),r._v(" "),n("p",[r._v("检测是否为数组\n1.instanceof 运算符// console.log(arr1 instanceof Array)\n2.Array.isArray(arr1) // console.log(Array.isArray(arr1)) 能检测iframes 更优一些 IE9+")]),r._v(" "),n("p",[r._v("新增数组元素\n//1.修改length长度\nvar arr = [2,6,1,7,4,77,52,25]\narr.length = arr.length + 3;\nconsole.log(arr)\nconsole.log(arr[11]) //undefined\n//2.新增数组元素\nvar arr = [2,6,1,7,4,77,52,25]\narr[11] = 11\nconsole.log(arr)")]),r._v(" "),n("p",[r._v("添加数组元素的方法\n1.push() //在末尾添加一个或多个元素\nvar arr1 = [1,2,3]\n// arr1.push(4,'5')//参数为新加元素\nconsole.log(arr1.push(4,'5')) //返回的是新数组长度\nconsole.log(arr1) //元素组也会发生变化\n2.unshift() //开头添加\n3.pop() //不用加参数；返回值是删除的元素；删除数组最后一个元素\n4.shift() //删除第一个元素")]),r._v(" "),n("p",[r._v("数组排序方法\n1.revers() //翻转\n2.sort() //冒泡排序，从小到大；注意是按每个数的最高位排序\nvar arr = [22,4,3,33,111,1]\nconsole.log(arr.sort()) // 1,111,22,3,33,4\n解决方法：\nconsole.log(arr.sort(function (a, b){\nreturn a - b //表升序  b -a 表降序\n}))")]),r._v(" "),n("p",[r._v("数组索引方法\n1. indexOf() //给定元素的索引号,只会返回第一个满足条件的索引号；如果找不到返回-1\n2. lastIndexOf() //从后往前找，索引号的顺序不会变，简单了解就行了")]),r._v(" "),n("p",[r._v("数组去重：核心算法：遍历旧数组，与新数组对比\nvar arr1 = [22,4,3,33,111,1,2,2,2,2,3,3,3,33,1,11,111]\nfunction unique(arr){\nvar newArr = []\nfor (var i = 0; i < arr.length; i++){\nif (newArr.indexOf(arr[i]) === -1){\nnewArr.push(arr[i])\n}\n}\nreturn newArr\n}\nvar result =  unique(arr1)\nconsole.log(result)")]),r._v(" "),n("p",[r._v("将数组转化为字符串\n1. toString // arr.toString() // 1,2,3\n2. join(分隔符) // arr.join('&') // 1&2&3\n其他数组对象\n1. concat() // 连接多个数组，返回新数组\n2. slice(begin,end) // 返回截取的新数组\t\n3. splice(第几个开始，要删除的个数) //返回被删除后的新数组；注意会影响原数组")]),r._v(" "),n("p",[r._v("创建数组\ntips: 建议使用数组字面量方式【简单】\nvar colors = new Array()\nvar colors = new Array('red','blue')\nvar colors = [];\nvar colors = ['red','blue'];")]),r._v(" "),n("p",[r._v("检测数组\n对于一个网页或一个全局作用域，可以通过如下方法\nif(arr instanceof Array){    //对数组执行某些操作}\n网页中包含多个框架，通过如下ES5方法检测\nif(Array.isArray(arr)){    //对数组执行某些操作}")]),r._v(" "),n("p",[r._v("转换方法\narr.valueOf()\nvar colors = ['red','blue','green']\ncolors.valueOf() //['red','blue','green']")]),r._v(" "),n("p",[r._v("arr.toString()\nvar colors = ['red','blue','green']\ncolors.toString() //\"red,blue,green\"")]),r._v(" "),n("p",[r._v("tips: arr.toString() 与 arr.join()输出相同，不过join里可以输入其它链接符")]),r._v(" "),n("p",[r._v("push、pop、unshift、shift\narr.push(item)\n接受任意数量的参数，添加到数组末尾，返回新数组的长度\nvar colors = ['red']\ncolors.push('blue','green'); //3")]),r._v(" "),n("p",[r._v("arr.pop()\n删除数组最后一项，返回删除的项\nvar colors = ['blue','green']\ncolors.pop() //green")]),r._v(" "),n("p",[r._v("arr.unshift()\n接受任意数量的参数，添加到数组头部，返回新数组的长度\nvar colors = ['red']\ncolors.unshift('green') //2")]),r._v(" "),n("p",[r._v("arr.shift()\n删除数组第一项，返回删除的项\nvar colors = ['blue','green']\ncolors.shift() //blue")]),r._v(" "),n("p",[r._v("reverse、sort、concat、slice\nsort扩展(非数字类型排序，对象里的某个key值排序)")]),r._v(" "),n("p",[r._v('arr.concat()\n没有传递参数，那么只是复制当前数组并返回副本，原数组不变；\n传递一个元素（数组）或多个元素（数组）,会将其合并到arr中，返回新数组，原数组不变\nvar colors = [\'red\',\'blue\',\'green\']\ncolors.concat(\'gray\',[\'a\',\'green\'])  //["red", "blue", "green", "gray", "a", "green"]\nconsole.log(colors) // ["red", "blue", "green"]\ntips: js数组复制\n[...arr]   //ES6\nArray.from(arr) //ES6\n$.extend(arr) //JQ')]),r._v(" "),n("p",[r._v('查找元素\narr.indexOf(searchValue, [start])\n验证数组中是否含有某个元素，返回第一个匹配到的元素在数组中所在的位置，如果没有，则返回 -1\n第二个参数是起始位置 0 到 length -1\nvar colors =  ["red", "gray", "yellow"]\ncolors.indexOf(\'gray\') // 1\ncolors.indexOf(\'mm\') //-1\narr.lastIndexOf()\n验证数组中是否含有某个元素，不过是从数组尾部开始查找，返回第一个匹配到的元素所在的位置，如果没有，则返回-1\nvar colors =  ["red", "gray", "yellow","gray"]\ncolors.indexOf(\'gray\') // 3\ncolors.lastIndexOf(\'mm\') //-1')]),r._v(" "),n("p",[r._v("ES6数组方法扩展\n1、求一个数组中最大元素\n由于js不提供求数组最大元素的函数，所以只能套用Math.max函数将数组转为一个参数序列，然后求最大值；有了扩展运算符以后就可以直接使用了Math.max了\n//ES5的写法\nMath.max.apply(null,[1,3,6]) ///6\n//ES6的写法\nMath.max(...[1,3,6]) //6\n2、通过push函数将一个数组添加到另一个数组的尾部\nES5的写法中，push的参数不可以是数组，所以只好通过apply方法变通使用push方法；有了扩展运算符，可以直接将数组传入push方法中\n//ES5的写法\nvar arr1 = [1,2]\nvar arr2 = [4,5]\nArray.prototype.push.apply(arr1,arr2) //返回新数组长度，arr1改变\n//ES6的写法\nvar arr1 = [1,2]\nvar arr2 = [4,5]\narr1.push(...arr2) //返回新数组长度，arr1改变\n3、合并数组\n//ES5写法\nvar arr = [4,5]\n[1,2].concat(arr) //[1, 2, 4, 5]\n//ES6写法\nvar arr = [4,5]\n[1,2,...arr]\n4、Array.from()妙用\n//数组去重\nfunction combine(){\nlet arr = []..apply([], arguments);  //没有去重复的新数组\nreturn Array.from(new Set(arr));\n}\nvar m = [1, 2, 2], n = [2,3,3];\nconsole.log(combine(m,n)); // [1, 2, 3]\n//遍历Nodelist对象\nlet ps = document.querySelectorAll('p')\nArray.from(ps).forEach(function(p){\nconsole.log(p)\n})\n//将字符串转化为数组\nArray.from('hello') //[\"h\", \"e\", \"l\", \"l\", \"o\"]\n5、Array.of()\n替代Array() 或 new Array(),并且不存在参数不同而导致的重载\nArray.of(2,3,5) //[2,3,5]\nArray.of(2) //[2]\nArray.of(2).length //1\n6、arr.copyWithin()\n将当前数组内部制定位置的成员复制到其他位置，返回当前新数组，原数组改变\n接收三个参数[从该位置开始替换 | 从该位置开始读取数据 | 到该位置停止读取数据]\n//将4,5移动到前两位\n[1,2,3,4,5].copyWithin(0,3) //[4,5,3,4,5]\n8、arr.fill()\n用给定的值填充一个数组\n['a','b','c'].fill(7) //[7,7,7]\n['a','b','c'].fill(7,1,2) //['a',7,'c']\n9、arr.includes()\n数组是否包含某个值，返回true 或 false\n[1,2,3].includes(2) //true\n10、for...of...\n遍历数组元素\nfor(let item of colors){\nconsole.log(item) // red,gray,yellow\n}\ntips:里面可以使用break continue提升效率\nJquery方法\n$.each(arr, fn)\n遍历数组或者对象，fn有2个参数，分别为， 比原生的for in 更加健壮\n[ 数组的索引或者对象的key值 | 索引或者key值对应的value值 ]\nvar arr = [1, 2, 3];\n$.each(arr, function(key, value) {\n// do something\n});\ntips:跳过一次循环 return | return true 终止循环 return false\n$.grep(arr, fn)\n过滤方法，功能类同原生中的arr.filter(fn)。此处fn的参数如下\n[ value: 对象/数组的值 | key值或者序列 ]\nvar arr = [ 1, 3, 6, 4 ];\n$.grep(arr, function(val, key) {\nreturn val >= 3;\n});\n// > [3, 6, 4]\n// arr : [ 1, 3, 6, 4 ] 不会改变\n$.map(arr, fn)\n对每项进行处理，返回处理结果组成的数组，此处fn的参数如下\n[ value: 对象/数组的值 | key值或者序列 ]\nvar arr = [1, 2, 5, 3];\n$.map(arr, function(val, key) {\nreturn val * 10;\n})\n// > [10, 30, 30, 20, 10]\n// 原数组不受影响\n$.inArray(item, array)\n检测某一个元素item是否存在与数组之中，返回其所在的位置，如果不在，则返回-1\n$.inArray(3, [1, 2, 3]);\n// > 2\n$.merge(arr1, arr2)\n合并数组，会改变第一个参数的数组为合并之后的数组，返回合并之后的数组\nvar arr = [1, 3, 4];\nvar arr2 = [4, 3, 1];\n$.merge(arr, arr2);\n// > [1, 3, 4, 4, 3, 1]\n// 为了防止第一个数组被改变，可以使用下面的方式来写\n$.merge($.merge([], arr), arr2);\n$.unique(arr)\n过滤DOM数组中重复的元素\n$.makeArray(obj)\n将类数组对象转换为数组\n$(elem).toArray()\n将jQuery对象集合恢复成DOM数组")])])}),[],!1,null,null,null);n.default=o.exports}}]);