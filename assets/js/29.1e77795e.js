(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{435:function(n,e,a){"use strict";a.r(e);var t=a(2),l=Object(t.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("p",[n._v("数据类型\n1.分类\n-基本/值类型\nString：任意字符串\nNumber：任意数字\nBoolean：true/false\nUndefined：undefined\nNull：null\n-对象/引用类型\nObject:\t任意对象\nFunction： 可以执行的对象\nArray：\t有序的对象\t\n2.如何判断\n===\n判断undefined和null")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v('typeof//返回的是字符串，注意小写\n\t可以判断undefined/数值/字符串/布尔值/函数\n\t！不能判断null和object array和object \n\nvar a\nconsole.log(a,typeof a); // undefined,"undefined"\n\ninstanceof //专用判断对象的具体类型，函数/数组\ninstance/实例\n')])])]),e("p",[n._v("ex.\nvar b1 = {}\nconsole.log(b1 instanceof Object) //b1是否是Object的实例\n类型是通过构造函数表达\nObject是一个构造函数 b1是Object的实例")]),n._v(" "),e("p",[n._v("什么是实例\n实例和类型\n实例是实例对象\n类型是类型对象\nfunction Person(name,age){ //设置（P）构造函数，即类型\nthis.name = name\nthis.age = age\n}\nvar p = new Person('tom',12) //根据类型创建的实例对象，在new时，才知道是构造函数")]),n._v(" "),e("p",[n._v("相关问题\n1.undefined与null的区别\nundefined:定义了未赋值\nnull：定义了并赋值，值为null\n2.什么时候给变量赋值null\nvar b = null //初始赋值为null 表将赋值为对象\nb = ['maomao',12]\nb = null //最后赋值为Null 表回收垃圾对象\nb = 2\t//用2代替Null,产生了新的垃圾数据")]),n._v(" "),e("p",[n._v("3.严格区分变量类型和数据类型\n数据类型\n-基本类型\n-对象类型\n变量类型（变量内存值的类型）//js是弱类型语言\n-基本类型：保存基本类型数据\n-引用类型：保存地址值\nvar c = {} // c里存的是对象的地址，c本身不是对象")]),n._v(" "),e("p",[n._v("数据 变量 内存\n1.什么是数据\n存储在内存中代表特定信息的01\n2.什么是内存\n内存条通电后产生的可存储的数据空间（临时的）\n一块小内存的2个数据，一个是内部数据，一个是自身的地址数据，对象内存才会用到地址值")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("内存分类\n堆：全局/局部变量\n栈：对象\n")])])]),e("p",[n._v("3.什么是变量\n可变化的量，变量名+变量值\n每个变量都对应一个小内存，变量名用来查找对应的内容，是一个标识\n变量值是内存中保存的数据\nobj.name 能.表面存的是地址\nname:'Tom'  ：左边是标识，右边是值；name是对象内的数据，在堆\nvar a = obj 用的是内部数据，直接将b的数据直接复制一份给a")])])}),[],!1,null,null,null);e.default=l.exports}}]);