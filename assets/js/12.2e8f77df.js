(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{419:function(n,e,r){"use strict";r.r(e);var t=r(2),o=Object(t.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("p",[n._v("数组方法\n// arr.slice(start,end)\n// 剪切数组，返回剪切之后的数组，不改变原数组\n// 1、传入一个参数，表示起始位置，结束位置为最末尾\nvar colors = ['red','blue','green']\ncolors.slice(2) //['green']\n// 2、传入2个参数，表示起始位置与结束位置，但不包括结束位置所在的元素\ncolors.slice(1,2) //['blue']")]),n._v(" "),e("p",[n._v("// arr.splice(startIndex,deleteCount,item) 返回删除元素组成的数组，原数组变了\n// [起始位置（ 数组下标） | 要删除的项数 为0 | 要插入的元素]\n// tips:这个方法会因为参数的不同而实现不同的功能\n// 1.删除：arr.splice(startIndex, deleteCount)\n// 传入两个参数，第一个为位置（ 数组下标），第二个为删除的项数，可以删除任意项，\nvar colors = ['red','blue','green']\ncolors.splice(1,1) //['blue']\n//2.添加元素 删除项数为0\nvar colors = ['red','blue','green']\ncolors.splice(1,0,'gray') //[]\nconsole.log(colors) // ['red','gray','blue','green']\n//3.替换元素\nvar colors = [\"red\", \"gray\", \"blue\", \"green\"]\ncolors.splice(2,2,'yellow') // [\"blue\", \"green\"]\nconsole.log(colors); //[\"red\", \"gray\", \"yellow\"]")]),n._v(" "),e("p",[n._v("数组迭代和reduce归并")]),n._v(" "),e("p",[n._v("迭代方法\nES5定义了5个迭代方法\n每个方法接收2个参数\n要在每一项上运行的函数 | 运行该函数的作用域对象（可选）")]),n._v(" "),e("p",[n._v("运行的函数包括3个参数\n[数组项的值 | 该项在数组中的位置 | 数组对象本身")]),n._v(" "),e("p",[n._v("arr.every()\n检查数组中的项是否满足某个条件\n每一项都返回true,则返回true\nvar nums = [1,2,3,4,5,4,3,2,1]\nnums.every((item, index, arr)=> item >2 ) //false")]),n._v(" "),e("p",[n._v("arr.some()\n检查数组中的项是否满足某个条件\n数组中某一项返回true,则返回true\nvar nums = [1,2,3,4,5,4,3,2,1]\nnums.some((item, index, arr)=> item >2 ) //true")]),n._v(" "),e("p",[n._v("arr.forEach()\n对数组中的每一项运行给定函数，这个方法没有返回值\n//返回nums中每一项乘以2的数组\nvar nums = [1,2,3,4,5,4,3,2,1]\nnums.forEach((item, index, arr)=> item * 2 ) // undefined")]),n._v(" "),e("p",[n._v("tips： map、forEach里不可以使用continue、break ,每一项都会执行，如果遍历中要用到continue或break提升效率，则可以使用for()循环 或 for...of..循环")]),n._v(" "),e("p",[n._v("此处方法都会对数组进行遍历\n参数一般为：函数")]),n._v(" "),e("p",[n._v("arr.filter()\n返回true的项组成的新数组\n//返回nums中所有值大于2的数组\nvar nums = [1,2,3,4,5,4,3,2,1]\nnums.filter((item, index, arr)=> item >2 ) //[3, 4, 5, 4, 3]")]),n._v(" "),e("p",[n._v("arr.map((item, index, self)=> ({}) )\n返回每次函数调用的结果组成的新数组\n//返回nums中每一项乘以2的数组\nvar nums = [1,2,3,4,5,4,3,2,1]\nnums.map((item, index, self)=> item * 2 ) // [2, 4, 6, 8, 10, 8, 6, 4, 2]")]),n._v(" "),e("p",[n._v("7、arr.find()     arr.findIndex()\n找到返回true,没找到返回undefined,  true的子item 会被返回\n只返回第一个\n[1,4,9,10,15].find((item, index, arr)=>{\nreturn item > 9;\n}) //10\n[1,4,9,10,15].findIndex((item, index, arr)=>{\nreturn item > 10;\n}) //4")]),n._v(" "),e("p",[n._v("归并操作\narr.reduce(function（PRE,CUR,INDEX,ARR）=> ({}) , {})\nreduce接收两个参数\n1.函数接收4个参数[前一个值 | 当前值 | 项的索引 | 数组对象本身]\n2. 初始值")]),n._v(" "),e("p",[n._v("从左开始\n//求数组所有元素之和\nvar nums = [1,2,3,4,5]\nnums.reduce((prev,cur,index,arr)=>prev+cur) //15")]),n._v(" "),e("p",[n._v("arr.reduceRight()\n从右开始")]),n._v(" "),e("p",[n._v("//计算每个元素出现的次数\n        // {name: 1, age: 2, GENDER: 3}\n        let arr = ['name','age','age','GENDER','GENDER','GENDER']\n        let result = arr.reduce((pre,cur) => {\n            if(!pre[cur]){\n                pre[cur] = 1\n            }else{\n                pre[cur]++\n            }\n            return pre\n        },{})\n        console.log(result);")]),n._v(" "),e("p",[n._v("// 字符转出现最多的字符，出现了几次\n        const find = (str)=>{\n            // 字符串转数组 [...str]\n            const map = [...str].reduce((pre,cur)=>{\n                if(!pre[cur]){\n                    pre[cur] = 1\n                }else{\n                    pre[cur]++\n                }\n                return pre\n            },{})\n            // console.log(map); {h: 1, e: 1, l: 2, o: 1}\n            // 将对象转为数组，这是一个二维数组\n            // console.log(Object.entries(map)); 0: (2) ['h', 1]\n            // 数组的解构赋值\n            const [[chart,count]] = Object.entries(map).sort(([,val1],[,val2])=> val2 -val1)\n            // console.log(arr); 0: (2) ['l', 2]\n            // console.log(chart,count); l 2\n            return {\n                chart,\n                count\n            }\n        }\n        console.log(find('hello'));")]),n._v(" "),e("p",[n._v("数组的交集，补集和并集\n  const arrOne = [1,2,3]\n        const arrTwo = [2,3,4,5]\n        //数组交集 [2,3]\n        const intersectionFn = (arr1,arr2)=>{\n            // filter 返回true的项组成的新数组\n            const result = arr1.filter(item1 => {\n                // some 检查数组中的项是否满足某个条件 数组中某一项返回true,则返回true\n                return arr2.some(item2 => {\n                    return item2 === item1\n                })\n            })\n            console.log('交集',result);\n            return result\n        }\n        intersectionFn(arrOne,arrTwo)\n        //数组补集 arr2的补集\n        const completeFn = (arr1,arr2)=>{\n            // every 检查数组中的项是否满足某个条件 每一项都返回true,则返回true\n            const result = arr1.filter( item1 => arr2.every( item2 => item2 !== item1))\n            console.log('arr2的补集',result);\n            return result\n        }\n        completeFn(arrOne,arrTwo)\n        //数组并集 [1,2,3,4,5]\n        const unionFn = (arr1,arr2)=>{\n            //concat\n            //没有传递参数，那么只是复制当前数组并返回副本，原数组不变；\n            //传递一个元素（数组）或多个元素（数组）,会将其合并到arr中，返回新数组，原数组不变\n            const result = arr1.filter( item1 => arr2.every( item2 => item2 !== item1)).concat(arr2)\n            console.log('并集',result);\n            return result\n        }\n        unionFn(arrOne,arrTwo)")]),n._v(" "),e("p",[n._v("//当数组的数据是对象时，要利用对象的属性来判断\n        const classOne = [\n            {userId:1, name:'小赵'},\n            {userId:2, name:'Tom'},\n            {userId:3, name:'Mary'}\n        ]    \n        const classTwo = [\n            {userId:2, name:'Tom'},\n            {userId:3, name:'Mary'},\n            {userId:4, name:'小张'}\n        ]      \n        const intersectionFn = (arr1,arr2)=>{\n            const result = arr1.filter( item1 => arr2.some(item2 => item2.userId === item1.userId))\n            console.log('交集',result);\n            return result\n        }  \n        intersectionFn(classOne,classTwo)\n        const completeFn = (arr1,arr2)=>{\n            const result = arr1.filter( item1 => arr2.every(item2 => item2.userId !== item1.userId))\n            console.log('arr2的补集',result);\n            return result\n        }  \n        completeFn(classOne,classTwo)\n        const unionFn = (arr1,arr2)=>{\n            const result = arr1.filter( item1 => arr2.every(item2 => item2.userId !== item1.userId)).concat(classTwo)\n            console.log('并集',result);\n            return result\n        }  \n        unionFn(classOne,classTwo)")]),n._v(" "),e("p",[n._v("数组排序sort，reverse")]),n._v(" "),e("p",[n._v("arr.reverse()\n反转数组的顺序，并返回重新排序之后的数组， 原数组会被改变\nvar arr1 = [1,2,3,'red','blue']\narr1.reverse() //[\"blue\", \"red\", 3, 2, 1]")]),n._v(" "),e("p",[n._v("arr.sort()\n如果不传参数，默认情况下数组内的元素会被转换为字符串进行比较，因此一般不推荐直接使用默认的arr.sort()进行排序。")]),n._v(" "),e("p",[n._v("返回值排序后的新数组。原数组会被改变\n注意：sort里接收一个比较函数\nvar b = [1,2,3]\n//升序\nb.sort((a,b)=>a-b) //[1, 2, 3]\n//降序\nb.sort((a,b)=>b-a) //[3, 2, 1]")]),n._v(" "),e("p",[n._v("数组求和以及斐波那契数列\n    const data = [1,2,3,4]\n        const sum = (arr)=>{\n            let result = 0\n            for( let i = 0; i<arr.length; i++){\n                result = arr[i] + result\n            }\n            console.log('合计',result);\n            return result\n        }\n        sum(data)\n        // 斐波那契数列 F(0) = 0 F(1) = 1 F(2)=1 F(n) = F(n-1) = F(n-2) n>= 2 n属于正整数\n        // 当前数 = 前两位数之和\n        // 目标：问第几项，得到那一项的值\n        // 1.递归的方法 - 性能缺陷\n        const getValue = (n)=>{\n            if(n < 2){\n                return n\n            }\n            return getValue(n-1) + getValue(n-2)\n        }\n        console.log('递归',getValue(3));\n        // 2.动态规划\n        const dynamicGetValue = (n)=>{\n            if(n < 2){\n                return n\n            }\n            let numArr = [0,1]\n            // for循环变量 性能高\n            for(let i = 2; i<= n; i++){\n                numArr.push(numArr[0] + numArr[1]) //[0, 1, 1]\n                // 删除：splice(index, num)\n                // 传入两个参数，第一个为位置（ 数组下标），第二个为删除的项数，可以删除任意项，返回删被除元素组成的数组，原数组变了\n                // 传入3个参数， [起始位置（ 数组下标） | 要删除的项数 为0 | 要插入的元素]， 最终返回被删除掉的元素组成的数组，因为这里删除项数为0，因此会返回空数组\n                numArr.splice(0,1) //[1, 1]\n            }\n            return numArr[1]\n        }\n        console.log('动态',dynamicGetValue(2));")]),n._v(" "),e("p",[n._v("简单：数组和等于目标值")]),n._v(" "),e("p",[n._v("const data = [\n            {userId: 1, name:'小明', chineseScore: 90, mathScore: 90},\n            {userId: 2, name:'小往', chineseScore: 80, mathScore: 90},\n            {userId: 3, name:'小张', chineseScore: 70, mathScore: 90},\n            {userId: 4, name:'小李', chineseScore: 60, mathScore: 90},\n            {userId: 5, name:'小白', chineseScore: 50, mathScore: 90},\n        ]\n        // 找出成绩高于170的学生\n        const filterStudent = (arr,target)=>{\n            let result = []\n            for(let i = 0; i < arr.length; i++){\n                if(arr[i].chineseScore + arr[i].mathScore >= target){\n                    result.push(arr[i].name)\n                }\n            }\n            console.log(result);\n            return result\n        }\n        filterStudent(data,170)\n        // 给定一个数组,给定一个目标值，返回数组内满足条件的下标组合\n        const nums = [3,2,7,11,15]\n        const findTarget = (nums,target)=>{\n            let result = {}\n            for(let i = 0; i < nums.length; i++){\n                for(let j =0; j < nums.length; j++){\n                    if(nums[i] + nums[j] === target){\n                        return { index:[i,j], value:[nums[i],nums[j]]}\n                    }\n                }\n            }\n        }\n        let result = findTarget(nums,9)\n        console.log(result);")]),n._v(" "),e("p",[n._v("数组去重for filter set")]),n._v(" "),e("p",[n._v("// 数组去重\n        //1.for循环嵌套\n/ / 借助新数组，如果原数组中的值 与其重复则不插入\n        var arr = [8,11,11,13,14,14,15]\n        var newArr = []\n        newArr[0] = arr[0]\n        // arr中每个元素\n        for(var i =0 ; i< arr.length; i++){\n            // 新数组中每个元素\n            for(var k =0; k < newArr.length; k++){\n                // 如果有相同得，没必要继续内循环\n                if(arr[i] === newArr[k]){\n                    break\n                }\n                // 直到比到新数组最后一项，才知道是否要插入\n                if(k === newArr.length -1 ){\n                    newArr.push(arr[i])\n                }\n            }\n        }\n        console.log(newArr);")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("或\n        var arr = [8,11,11,13,14,14,15]\n        const forRemoveDuplicate = (arr)=>{\n            for(let i =0 ; i< arr.length; i++){\n                for( let j = i+1; j< arr.length; j++){\n                    if(arr[i] === arr[j]){\n                        arr.splice(j,1)\n                        j--\n                    }\n                }\n            }\n            return arr\n        }\n        let result = forRemoveDuplicate(arr)\n        console.log(result);\n\n//filter去重\n        const forRemoveDuplicate = (arr)=>{\n            // 返回true的项组成的新数组\n            return arr.filter((item,index,self)=>{\n                // indexOf 第一个匹配到的元素的位置\n                return self.indexOf(item) === index\n            })\n        }\n//es6 set去重\n        var arr = [8,11,11,13,14,14,15,16]\n        const es6RemoveDuplicate = (arr)=>{\n            return Array.from(new Set(arr))\n        }\n        let result = es6RemoveDuplicate(arr)\n        console.log(result);\n")])])]),e("p",[n._v("将对象类型数据转为数组对象\n    const data = {\n            beijing:100,\n            shanghai : 60,\n            guangzhou: 80\n        }\n        // (3) [{…}, {…}, {…}]\n            // 0: {name: 'beijing', value: 100}\n            // 1: {name: 'shanghai', value: 60}\n            // 2: {name: 'guangzhou', value: 80}\n        const objToArr = (data, realName, realValue)=>{\n            // console.log(Object.keys(data)); //['beijing', 'shanghai', 'guangzhou']\n            const res = Object.keys(data).map((key)=>{\n                return{ [realName]: key, [realValue]:data[key] }\n            })\n            console.log(res);\n            return res\n        }\n        objToArr(data,'name','value')\n数组对象转为普通对象\n  const data1 = [ //二维数组"),e("br"),n._v("\n            ['key1','value1'],\n            ['key2','value2']\n        ]\n        console.log(Object.fromEntries(data1));\n        // {key1: 'value1', key2: 'value2'}")]),n._v(" "),e("p",[n._v("// 数组对象转为普通对象\n        const data = [\n            {name: 'beijing', value: 100},\n            {name: 'shanghai', value: 60},\n            {name: 'guangzhou', value: 80}\n        ]\n        //     {\n        //     beijing:100,\n        //     shanghai : 60,\n        //     guangzhou: 80\n        //      }\n        const arrToObj = (data,realName,realValue)=>{\n            // 返回每次函数调用的结果组成的新数组\n            const res = data.map((item)=>{\n                return [ item[realName], item[realValue]]\n            })\n            console.log(res); //得到二维数组\n            return Object.fromEntries(res)\n        }\n        let result = arrToObj(data,'name','value')\n        console.log(result);\n数据分组处理")]),n._v(" "),e("p",[n._v("// 根据年级表和学生表，生成学生对象\n        const gradeList = [\n            { grade1: '一年级'},\n            { grade2: '二年级'},\n            { grade3: '三年级'}\n        ]\n        const studentList = [\n            { grade1: ['小明','小郑','小张']},\n            { grade2: ['阿毛','阿毛毛','阿阿毛']},\n            { grade3: ['tom','jacj','jerry']}\n        ]\n        // 想得到\n        // students = [\n        //     {name : '小明' ,grade : '一年级'}\n        // ]\n        const parseDataFn = (data, gradeList)=>{\n            let result = []\n            for ( let i = 0; i < data.length; i++){\n                const item = data[i] // grader1 [...]\n//for in 用于循环对象\n                for (const key in gradeList[i]) {\n                    console.log(key); // grade1\n                    for( let j = 0; j < item[key].length; j++){\n                        const nameValue = item[key][j] // 拿到每个学生名字 小明，小张...\n                        result.push({name : nameValue, grade: gradeList[i][key]})\n                    }\n                }\n            }\n            console.log(result);\n            return result\n        }\n        parseDataFn(studentList,gradeList)\n数组，字符串at方法 取最后一个元素\n  // 数组，字符串at方法 取最后一个元素\n    const arr = [1,2,3,4]\n    console.log(arr.at(-1)); // 4 倒一\n    console.log(arr.at(-2)); // 3 倒二\n处理小数点位数\n根据num获取它的小数点位数\n0.1 -> 1位")]),n._v(" "),e("p",[n._v("const getDecimal = (num)=>{\n      let len = 0\n      if(Math.floor(num) === num){\n        //如果是整数\n        return 0\n      }\n      // 利用字符串的substr方法\n      // var str=\"Hello world!\";\n      // var n=str.substr(2,3)  //llo\n      const str = String(num)\n      const pointIndex = str.indexOf('.') //小数点下标\n      console.log(str.substr(pointIndex + 1)); //得到小数点后的数字的 str  \n      len = str.substr(pointIndex + 1).length\n      console.log(len);\n      return len\n    }\n    getDecimal(0.12342)\n数字加法运算\n// 数字加法，把小数转为整数运算 再除回去\n    console.log(0.1+0.2); //0.30000000000000004\n    console.log(1+2); //3")]),n._v(" "),e("p",[n._v("const add = (n1,n2)=>{\n      let result = 0\n      const n1Len = getDecimal(n1)\n      const n2Len = getDecimal(n2)\n      const maxLen = n1Len > n2Len ? n1Len : n2Len\n      // Math.pow(4,3); 4的3次方\n      // 这里就是10的 maxLen 次方\n      const maxTimes = Math.pow(10, maxLen)\n      console.log(maxLen, maxTimes); // 1 10\n      result = (n1 * maxTimes + n2 * maxTimes) / maxTimes\n      console.log(result);\n      return result\n    }\n    add(9,0.0002)\n数字乘法\n// 数字乘法\nconsole.log(1 * 2); //2\nconsole.log(0.1 * 0.2); //0.020000000000000004\n      const mulFn = (n1,n2)=>{\n      let result = 0\n      const n1Len = getDecimal(n1)\n      const n2Len = getDecimal(n2)\n      const maxLen = n1Len > n2Len ? n1Len : n2Len\n      // Math.pow(4,3); 4的3次方\n      // 这里就是10的 maxLen 次方\n      const n1Times = Math.pow(10, n1Len)\n      const n2Times = Math.pow(10, n2Len)\n      result = (n1 * n1Times) *( n2 * n2Times) / (n1Times * n2Times)\n      console.log(result);\n      return result\n    }\n    mulFn(0.9,2)\n数字除法\nconsole.log(0.01 / 0.2); // 0.049999999999999996\nconsole.log(0.1 / 0.2); // 0.5\n    const divisionFn = (n1,n2)=>{\n      let result = 0\n      const n1Len = getDecimal(n1)\n      const n2Len = getDecimal(n2)\n      const maxLen = Math.max(n1Len,n2Len)\n      // Math.pow(4,3); 4的3次方\n      // 这里就是10的 maxLen 次方\n      const maxTimes = Math.pow(10, maxLen)\n      result = (n1 * maxTimes) / (n2 * maxTimes)\n      console.log(result);\n      return result\n    }\n    divisionFn(1,22)\nMath对象常用方法\n// Math对象相关方法\nconsole.log(Math.ceil(12.1) ); //13  向上取整\nconsole.log(Math.floor(12.1) ); // 12 向下取整\nconsole.log(Math.round(12.5) ); //13 四舍五入\nMath.max() //求最大值\nMath.pow(4,3) //求mi  4的三次方\nMath.abs() //求绝对值")]),n._v(" "),e("p",[n._v("检测变量类型toString()\n// toString 功能\n    // 1. 转化为字符串\n    const num = 123;\n    console.log('将数字转为字符串', num.toString());\n    // 2.返回一个表示该对象的字符串\n    // Object.prototype.toString.call()  通过call调用原型上的toString(防止重写)\n    console.log(Object.prototype.toString.call(num) ); //[object Number]\n    //第一个值表示Object 没啥含义\n    //第二个值 表表示该对象的字符串\ntoString()方法-检测变量类型\n  // object.prototype.toString.call()\n    const num = 321\n//toString 返回一个表示该对象的字符串\n    console.log(Object.prototype.toString.call(num)); //[object Number] 可以知道是number")]),n._v(" "),e("p",[n._v("XXX.toString() // xxx就是object")]),n._v(" "),e("p",[n._v("获取对象深层次的值\n    // 获取对象深层次的值\n        let res = {\n            status : 0,\n            msg: 'success',\n            data: {\n                config: {\n                    // style : {\n                    //     color: '#000'\n                    // }\n                    style : null\n                }\n            }\n        }\n       \n        // console.log(res.data.config.style.color);\n        // 如果其中有一个环节是null就会报错\n        // 取一个值之前要判断是否存在 方法1\n        // console.log(res.data && res.data.config && res.data.config.style && res.data.config.style.color);\n        // 方法2 配置选择符\n        console.log(res.data?.config?.style?.color); //注意遇到null会返回undefined\n        // 在哪里改?\n        // 方法3 safeGet函数 问题同二\n        const safeGet = (obj,path)=>{\n            const keys = path.split('.')\n            for (const key of keys) {\n                // console.log(key,keys);  data (4) ['data', 'config', 'style', 'color']\n                if (obj){\n                    obj = obj[key]\n                }\n            }\n            return obj\n        }\n        safeGet(res,'data.config.style.color')")]),n._v(" "),e("p",[n._v("toLocaleString 数值转货币\n  // toLocaleString(locale,options)  参数：1.语言类型字符串 2.配置对象\n        // 1.数字分割 123,456.789\n        const num1 = 123456.789\n        console.log(num1.toLocaleString()); //123,456.789\n        // 2.数字转为百分比\n        const num2 = 0.12\n        console.log(num2.toLocaleString('zh',{style: 'percent'})); //12%\n        // 3.数字转货币表示\n        const num3 = 1000000\n        console.log(num3.toLocaleString('zh',{style: 'currency', currency:'cny'})); //¥1,000,000.00\n        console.log(num3.toLocaleString('zh',{style: 'currency', currency:'cny',currencyDisplay:'code'})); //CNY 1,000,000.00\n        console.log(num3.toLocaleString('zh',{style: 'currency', currency:'cny',currencyDisplay:'name'})); //1,000,000.00人民币")]),n._v(" "),e("p",[n._v("当parseInt遇到map\nconst data = ['1','2','3']\n        console.log(data.map(parseInt)); //1 nan nan\n        // map里需要一个函数 函数有三个参数 item index self\n        // parseInt(str,[radix进制2-36]) 函数可解析一个字符串，并返回一个整数\n        // 1 0\n        // 2 1 //没有1进制\n        // 3 2 // 2进制里没有3\n        console.log(parseInt(\"0x10\",16));")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("   // parseInt(str,[radix进制2-36]) 函数可解析一个字符串，并返回一个整数\n")])])]),e("p",[n._v('// 当忽略参数 radix , JavaScript 默认数字的基数如下:\n        //     如果 string 以 "0x" 开头，parseInt() 会把 string 的其余部分解析为十六进制的整数。\n        //     如果 string 以 0 开头，那么 ECMAScript v3 允许 parseInt() 的一个实现把其后的字符解析为八进制或十六进制的数字。\n        //     如果 string 以 1 ~ 9 的数字开头，parseInt() 将把它解析为十进制的整数。')]),n._v(" "),e("p",[n._v('传送数据value是undefined时\n// 传送数据给后端，value是undefined时，被忽略，理想要{}\n        const formInfo = [\n            {\n                fieldId: 1,\n                value: undefined\n            },\n            {\n                fieldId:2,\n                value: 2\n            }\n        ]\n        const result = JSON.stringify(formInfo)\n        console.log(result,typeof(result));\n        // [{"fieldId":1},{"fieldId":2,"value":2}] string\n        // 以下处理\n        // 方法1\n        const newFormInfo = formInfo.map(item => {\n            const value = item.value === undefined ? \'\' : item.value\n            return {...item,value}\n        })\n        const result2 = JSON.stringify(newFormInfo)\n        console.log(result2);\n        // 方法2 利用JSON.stringfy的第二参数\n        const result3 = JSON.stringify(formInfo, (key,value)=> value === undefined? \'\' : value)\n        console.log(result3);')]),n._v(" "),e("p",[n._v("算法\n    // 根据roles数组，生成key:id值 value:角色名  对象\n    const initRoleNames = (roles:IRole[])=>{\n        const newRoleNames = roles.reduce((prev:any,role)=>{\n            prev[role._id] = role.name\n            return prev\n        } ,{})\n        // 保存起来\n        setRoleNames(newRoleNames)        \n    }")])])}),[],!1,null,null,null);e.default=o.exports}}]);