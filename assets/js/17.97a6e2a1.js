(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{423:function(n,o,e){"use strict";e.r(o);var t=e(2),a=Object(t.a)({},(function(){var n=this,o=n._self._c;return o("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[o("h1",{attrs:{id:"变量对象"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#变量对象"}},[n._v("#")]),n._v(" 变量对象")]),n._v(" "),o("p",[n._v("当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。\n对于每个执行上下文，都有三个重要属性：\n• 变量对象(Variable object，VO)\n• 作用域链(Scope chain)\n• this")]),n._v(" "),o("p",[n._v("变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。\n因为不同执行上下文下的变量对象稍有不同，所以我们来聊聊全局上下文下的变量对象和函数上下文下的变量对象。")]),n._v(" "),o("p",[n._v("全局上下文\n全局上下文中的变量对象就是全局对象！\n先了解一个概念，叫全局对象。在 W3School 中也有介绍：")]),n._v(" "),o("p",[n._v("全局对象是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。\n在顶层 JavaScript 代码中，可以用关键字 this 引用全局对象。因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询。\n例如，当JavaScript 代码引用 parseInt() 函数时，它引用的是全局对象的 parseInt 属性。全局对象是作用域链的头，还意味着在顶层 JavaScript 代码中声明的所有变量都将成为全局对象的属性。")]),n._v(" "),o("p",[n._v("如果看的不是很懂的话，容我再来介绍下全局对象:\n1.可以通过 this 引用，在客户端 JavaScript 中，全局对象就是 Window 对象。\nconsole.log(this);\n2.全局对象是由 Object 构造函数实例化的一个对象。\nconsole.log(this instanceof Object);\n3.预定义了一堆，嗯，一大堆函数和属性。\n// 都能生效\nconsole.log(Math.random());\nconsole.log(this.Math.random());\n4.作为全局变量的宿主。\nvar a = 1;\nconsole.log(this.a);\n5.客户端 JavaScript 中，全局对象有 window 属性指向自身。\nvar a = 1;\nconsole.log(window.a);\nthis.window.b = 2;\nconsole.log(this.b);\n函数上下文\n在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。\n活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object 呐，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。\n活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。\n引用《JavaScript权威指南》回答你哈：调用函数时，会为其创建一个Arguments对象，并自动初始化局部变量arguments，指代该Arguments对象。所有作为参数传入的值都会成为Arguments对象的数组元素。")]),n._v(" "),o("p",[n._v("未进入执行阶段之前，变量对象(VO)中的属性都不能访问！但是进入执行阶段之后，变量对象(VO)转变为了活动对象(AO)，里面的属性都能被访问了，然后开始进行执行阶段的操作。\n它们其实都是同一个对象，只是处于执行上下文的不同生命周期。@jDragonV")]),n._v(" "),o("p",[n._v("来自 "),o("a",{attrs:{href:"https://github.com/mqyqingfeng/Blog/issues/5",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://github.com/mqyqingfeng/Blog/issues/5"),o("OutboundLink")],1)]),n._v(" "),o("p",[n._v("执行过程\n分成两个阶段进行处理：分析和执行，我们也可以叫做：\n1. 进入执行上下文\n2. 代码执行")]),n._v(" "),o("p",[n._v("进入执行上下文\n当进入执行上下文时，这时候还没有执行代码，\n变量对象会包括：\n1. 函数的所有形参 (如果是函数上下文)\n○ 由名称和对应值组成的一个变量对象的属性被创建\n○ 没有实参，属性值设为 undefined\n2. 函数声明\n○ 由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建\n○ 如果变量对象已经存在相同名称的属性，则完全替换这个属性\n3. 变量声明\n○ 由名称和对应值（undefined）组成一个变量对象的属性被创建；\n○ 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性")]),n._v(" "),o("p",[n._v('举个例子：\nfunction foo(a) {\nvar b = 2;\nfunction c() {}\nvar d = function() {};\nb = 3;\n}\nfoo(1);\n在进入执行上下文后，这时候的 AO 是：\nAO = {\narguments: {\n0: 1,\nlength: 1\n},\na: 1,\nb: undefined,\nc: reference to function c(){},\nd: undefined\n}\n代码执行\n在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值\n还是上面的例子，当代码执行完后，这时候的 AO 是：\nAO = {\narguments: {\n0: 1,\nlength: 1\n},\na: 1,\nb: 3,\nc: reference to function c(){},\nd: reference to FunctionExpression "d"\n}\n到这里变量对象的创建过程就介绍完了，让我们简洁的总结我们上述所说：\n1. 全局上下文的变量对象初始化是全局对象\n2. 函数上下文的变量对象初始化只包括 Arguments 对象\n3. 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值\n4. 在代码执行阶段，会再次修改变量对象的属性值')]),n._v(" "),o("p",[n._v('1.第一题\nfunction foo() {\nconsole.log(a);\na = 1;\n}\nfoo(); // ???\nfunction bar() {\na = 1;\nconsole.log(a);\n}\nbar(); // ???\n第一段会报错：Uncaught ReferenceError: a is not defined。\n第二段会打印：1。\n这是因为函数中的 "a" 并没有通过 var 关键字声明，所有不会被存放在 AO 中。\n第一段执行 console 的时候， AO 的值是：\nAO = {\narguments: {\nlength: 0\n}\n}\n没有 a 的值，然后就会到全局去找，全局也没有，所以会报错。\n当第二段执行 console 的时候，全局对象已经被赋予了 a 属性，这时候就可以从全局找到 a 的值，所以会打印 1。\n2.第二题\nconsole.log(foo);\nfunction foo(){\nconsole.log("foo");\n}\nvar foo = 1;\n会打印函数，而不是 undefined 。\n这是因为在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。')]),n._v(" "),o("p",[n._v('主，有幸拜读你的深入系列，收获颇多，但也存在一些疑问。比如变量对象留给我们的思考题的第二题，按照你的写法：\nconsole.log(foo);\nfunction foo(){\nconsole.log("foo");\n}\nvar foo = 1; // 打印函数\n但个人觉得这句“这是因为在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。”解释得有点欠完整，如果我把代码改写成下面这样：\nvar foo = 1;\nconsole.log(foo);\nfunction foo(){\nconsole.log("foo");\n};\n这次打印结果就是“1”；\n所以我觉得这么解释比较好：\n进入执行上下文时，首先会处理函数声明，首先会处理函数声明，其次会处理变量声明，如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。\n进入代码执行阶段，先执行console.log(foo)，此时foo是函数的应用，再执行var foo = 1;将foo赋值为1，而在我改写的例子里中，先执行var foo = 1;再执行console.log(foo),所以打印1。我觉得加上代码执行阶段会更清晰，哈哈哈')]),n._v(" "),o("p",[n._v("一个执行上下文的生命周期可以分为两个阶段。\n1. 创建阶段\n在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向。\n1. 代码执行阶段\n创建完成之后，就会开始执行代码，这个时候，会完成变量赋值，函数引用，以及执行其他代码。\n都没有错，博主讲的主要是针对变量对象，而变量对象的创建是在EC(执行上下文)的创建阶段，所以侧重点主要是EC的生命周期的第一个阶段，我觉得再执行var foo = 1这句话有点不妥，应该是给foo赋值，应该是执行foo=1这个操作，因为在EC创建阶段var已经被扫描了一遍。")])])}),[],!1,null,null,null);o.default=a.exports}}]);