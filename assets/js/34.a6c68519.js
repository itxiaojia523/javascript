(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{434:function(n,o,t){"use strict";t.r(o);var e=t(2),i=Object(e.a)({},(function(){var n=this,o=n._self._c;return o("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[o("p",[n._v("js进阶")]),n._v(" "),o("p",[n._v("必包\n产生条件，函数嵌套且内部函数引用了外部函数变量，执行外部函数")]),n._v(" "),o("p",[n._v("什么是必包\n是一个内部函数的对象，含有被引用变量")]),n._v(" "),o("p",[n._v("作用：延长局部变量生命周期，\n使得外部能操作内部的变量\n将函数作为返回值\n将函数作为实参\n定义模块")]),n._v(" "),o("p",[n._v("遍历+监听\nfor(var i = 0;i <btns.length; i++){}")]),n._v(" "),o("p",[n._v("for(var i = 0, length = btns.length;i <length; i++){}\n第二种写法性能更好，length只计算一次")]),n._v(" "),o("p",[n._v("for(var i = 0, length = btns.length;i <length; i++){\nvar btn = btns[i]\nbtn.onclick = function (){\nalert('第'+(i+1)+'个') //一直是4\n}\n}\nconsole.log(i) /3\n1.遍历完了以后 才执行函数\n2.所以要给btn加一个下标\nvar btn = btns[i]\n//将btn所对应的下标保存在btn上\nbtn.index = i\nbtn.onclick = function (){\nalert('第'+(this.index+1)+'个')\n}")]),n._v(" "),o("p",[n._v("闭包\nfor(var i = 0, length = btns.length;i <length; i++){\n(function (i){\nvar btn = btns[i]\nbtn.onclick = function (){\nalert('第'+(i+1)+'个')\n}\n})(i)\n}")]),n._v(" "),o("p",[n._v("如何产生闭包\n1.嵌套的函数\n2.内部函数，引用了父函数的变量\n3.执行外部函数\n注意：不用调用内部函数，仅调用外部函数 就产生了")]),n._v(" "),o("p",[n._v("function f1(){\nvar a = 2\nvar b = 3\nfunction fn2() {\nconsole.log(a)\n}\n}\nf1()\n没引用b 所以闭包里没有b")]),n._v(" "),o("p",[n._v("什么是闭包\n理解1：是嵌套的内部函数（大多数人）\n理解2：是包含被引用变量的对象（在内部函数中） 少数人 通过chrome debug程序查看")]),n._v(" "),o("p",[n._v("常见的闭包\n1.将函数作为另外一个函数的返回值\nfunction f1(){\nvar a = 2\nfunction fn2() {\na++\nconsole.log(a)\n}\nreturn fn2\n}\nvar f = fn1() //如果没有闭包 fn1执行，a就没了，执行f，就报错了\n//这说明在反复执行函数的过程中 闭包中的数据没有消失！\nf()// a = 3\nf()// a = 4\nf = null //让闭包变成垃圾对象，死亡")]),n._v(" "),o("p",[n._v("2.将函数作为实参传递给另外一个函数\nfunction showDelay(msg, time){\nsetTimeout(function (){\nalert(msg)\n},time)\n}\nshowDelay('maomao',2000)")]),n._v(" "),o("p",[n._v("闭包的作用\n1.保存局部变量（函数执行完后，仍存在内存中，延长了局部变量的生命周期）\n2.在外部操作局部变量")]),n._v(" "),o("p",[n._v("闭包的应用\n1.定义JS模块 myModule\n-JS文件\n-将所有函数和功能封装在一个函数中\n-只向外暴露一个或多个方法的对象\n;function myModule(){\nvar msg = 'maomao'\nfunction doSomething(){\nconsole.log('doSomething()' + msg.toUpperCase())\n}\nfunction doOtherthing() {\nconsole.log('doOtherthing' + msg.toLowerCase())\n}\n//向外暴露对象，给外部使用的方法\nreturn {\ndoSomething: doSomething,\ndoOtherthing: doOtherthing\n}\n}\nvar module = myModule()\nmodule.doSomething()")]),n._v(" "),o("p",[n._v("或（推荐，更直接）\n;(function myModule(){\nvar msg = 'maomao'\nfunction doSomething(){\nconsole.log('doSomething()' + msg.toUpperCase())\n}\nfunction doOtherthing() {\nconsole.log('doOtherthing' + msg.toLowerCase())\n}\n//向外暴露对象，给外部使用的方法\nwindow.myModule2 = {\ndoSomething: doSomething,\ndoOtherthing: doOtherthing\n}\n})()\nmyModule2.doSomething()")]),n._v(" "),o("p",[n._v("最终版\n;(function myModule(window){\nvar msg = 'maomao'\nfunction doSomething(){\nconsole.log('doSomething()' + msg.toUpperCase())\n}\nfunction doOtherthing() {\nconsole.log('doOtherthing' + msg.toLowerCase())\n}\n//向外暴露对象，给外部使用的方法\nwindow.myModule2 = {\ndoSomething: doSomething,\ndoOtherthing: doOtherthing\n}\n})(window)\n如果没定义参数，不能压缩为w，与代码压缩相关")]),n._v(" "),o("p",[n._v("闭包的缺点\n1.函数内局部变量没有释放，占用内存事件会变长\n2.容易造成内存泄漏\n解决\n1.能不用就不用\n2.及时释放 即f = null")]),n._v(" "),o("p",[n._v("内存溢出与内存泄漏\n内存溢出：\n当一个程序运行需要的内存超过剩余的内存空间，就出现内存溢出的错误\n导致程序出现错误\n内存泄漏：\n占用的内存没有及时释放\n内存泄漏积累多了就容易导致内存溢出")]),n._v(" "),o("p",[n._v("常见的内存泄漏\n意外的全局变量 函数内部 a = 3（全局） 与 var a = 3 （局部）\n没有及时清理的计时器或回调函数  clearInterval\n闭包\t\tf = null")]),n._v(" "),o("p",[n._v("var name = 'The Window'\nvar obj = {\nname: 'My Obj',\ngetName: function () {\nreturn function () {\nreturn this.name\n}\n}\n}\nalert(obj.getName()())//相当于这个函数直接调用 function(){}(),this是window")]),n._v(" "),o("p",[n._v("var name = 'The Window'\nvar obj = {\nname: 'My Obj',\ngetName: function () {\nvar that = this\nreturn function () {\nreturn that.name\n}\n}\n}\nalert(obj.getName()())  //that 是getName的this，this就是obj\n！常用，将一个函数的this用变量存起来，最后用")]),n._v(" "),o("p",[n._v("function fun(n,o) {\nconsole.log(o)\nreturn {\nfun: function (m){\nreturn fun(m,n)\n}\n}\n}\nvar a = fun(0);//undefined 此时return一个对象，闭包产生n=0\na.fun(1) 0 //m =1  return fun(1,0)；执行fun(1,0) 输出0，\n新的闭包产生，但是立刻消失，没有接受return的结果\n如果是\nvar xxx = a.fun(1) //此时n=1\na.fun(2) 0\na.fun(3) 0")]),n._v(" "),o("p",[n._v("var b = fun(0).fun(1).fun(2).fun(3) //undefined 0 1 2\nvar c = fun(0).fun(1) undefined 0\nc.fun(2) //1\nc.fun(3) //1")]),n._v(" "),o("p",[n._v("分析：o=n 即闭包的值\n关注有没有产生新的闭包")])])}),[],!1,null,null,null);o.default=i.exports}}]);