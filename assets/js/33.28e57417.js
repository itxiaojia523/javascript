(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{436:function(n,t,e){"use strict";e.r(t);var o=e(2),p=Object(o.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("p",[n._v("方法1\t原型链继承\n步骤\n1.定义父子构造函数\n2.为使得子的实例 能访问父的原型的方法\n3.子类型的原型为父类型的一个实例对象")]),n._v(" "),t("p",[n._v("关键：子类型的原型为父类型的一个实例对象")]),n._v(" "),t("p",[n._v("//父的实例 能访问父的原型\n//子的实例 能访问子型\n//把子的原型 指向 父的实例\n//子实例 - 子原型 - 父实例 - 父原型")]),n._v(" "),t("p",[n._v('//定义父\nfunction Parent(){\nthis.pProp = "parent Prop"\n}\nParent.prototype.showParentProp = function () {\nconsole.log(this.pProp)\n}\n//定义子\nfunction Sub(){\nthis.sProp = "sub Prop"\n}\nSub.prototype.showSProp = function () {\nconsole.log(this.sProp)\n}')]),n._v(" "),t("p",[n._v("//让子类型的原型 成为 父类型的实例\nSub.prototype = new Parent()\ns1.showParentProp() //希望子类型的实例 能调用父类型原型上的方法 让子类型的原型\n成为 父类型的实例")]),n._v(" "),t("p",[n._v("var s1 = new Sub()\nconsole.log(s1.constructor) // Parent 不对需要改\nSub.Prototype.constructor = Sub")]),n._v(" "),t("p",[n._v("方法2 用call（）的假继承\nfunction P(name,age) {\nthis.name = name\nthis.age = age\n}")]),n._v(" "),t("p",[n._v("function Student(name,age,price) {\nP.call(this, name, age) // 结果同this.P(name, age)\nthis.price = price")]),n._v(" "),t("p",[n._v("}")]),n._v(" "),t("p",[n._v("最终：组合继承\ncall()函数搞来属性，继承搞来方法")]),n._v(" "),t("p",[n._v("function Person(name,age) {\nthis.name = name\nthis.age = age\n}\nPerson.prototype.setName = function(){}\n...多个方法")]),n._v(" "),t("p",[n._v("function Student(name,age,price) {\nPerson.call(this, name, age) //为了得到属性\nthis.price = price\n}\nStudent.prototype = new Person() //为了看到父类型的方法\nStudent.prototype.constructor = Student //修正构造器")]),n._v(" "),t("p",[n._v("不申明a\n直接log(window.a)//undefined log(a) //报错\n找作用域 与 代码执行位置无关！ ！！！")])])}),[],!1,null,null,null);t.default=p.exports}}]);